<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4790 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4790.xml">
<!ENTITY RFC5234 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml">
<!ENTITY RFC6265 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6265.xml">
<!ENTITY RFC6454 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6454.xml">
<!ENTITY RFC7034 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7034.xml">
]>

<rfc ipr="trust200902" docName="draft-west-first-party-cookies-01" category="std" updates="6265">

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

  <front>
    <title abbrev="first-party-cookies">First-Party-Only Cookies</title>

    <author initials="M." surname="West" fullname="Mike West">
      <organization>Google, Inc</organization>
      <address>
        <email>mkwst@google.com</email>
        <uri>https://mikewest.org/</uri>
      </address>
    </author>

    <date year="2015"/>

    <area>General</area>
    <workgroup>HTTPbis</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document updates RFC6265 by defining a <spanx style="verb">First-Party-Only</spanx> attribute which
allows servers to assert that a cookie ought to be sent only in a “first-party”
context. This assertion allows user agents to mitigate the risk of cross-origin
information leakage, and provides some minimal protection against cross-site
request forgery attacks.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Section 8.2 of <xref target="RFC6265"/> eloquently notes that cookies are a form of ambient
authority, attached by default to requests the user agent sends on a user’s
behalf. Even when an attacker doesn’t know the contents of a user’s cookies,
she can still execute commands on the user’s behalf (and with the user’s
authority) by asking the user agent to send HTTP requests to unwary servers.</t>

<t>Here, we update <xref target="RFC6265"/> with a simple mitigation strategy that allows
servers to declare certain cookies as “First-party-only”, meaning they should be
attached to requests if and only if those requests occur in a first-party
context (as defined in section 2.1).</t>

<t>Note that the mechanism outlined here is backwards compatible with the existing
cookie syntax. Servers may serve first-party cookies to all user agents; those
that do not support the <spanx style="verb">First-Party-Only</spanx> attribute will simply store a cookie
which is returned in all applicable contexts, just as they do today.</t>

<section anchor="goals" title="Goals">

<t>These first-party-only cookies are intended to provide a solid layer of
defense-in-depth against attacks which require embedding an authenticated
request into an attacker-controlled context:</t>

<t><list style="numbers">
  <t>Timing attacks which yield cross-origin information leakage (such as those
detailed in <xref target="pixel-perfect"/>) can be substantially mitigated by setting
the <spanx style="verb">First-Party-Only</spanx> attribute on authentication cookies. The attacker will
only be able to embed unauthenticated resources, as embedding mechanisms such
as <spanx style="verb">&lt;iframe&gt;</spanx> will not create first-party contexts.</t>
  <t>Cross-site script inclusion (XSSI) attacks are likewise mitigated by setting
the <spanx style="verb">First-Party-Only</spanx> attribute on authentication cookies. The attacker
will not be able to include authenticated resources via <spanx style="verb">&lt;script&gt;</spanx> or
<spanx style="verb">&lt;link&gt;</spanx>, as these embedding mechanisms will not create first-party contexts.</t>
</list></t>

<t>Aside from these attack mitigations, first-party-only cookies can also be useful
for policy or regulatory purposes. That is, it may be valuable for an origin to
assert that its cookies should not be sent along with third-party requests in
order to limit its exposure to non-technical risk.</t>

</section>
<section anchor="limitations" title="Limitations">

<t>First-party-only cookies provide only very limited defense against naïve
cross-site request forgery attacks (CSRF). They defend against directly
embedding vulnerable endpoints into an attacker-controlled context (as discussed
above), but this is not a robust defense in and of itself.</t>

<t><list style="numbers">
  <t>Attackers can still pop up new windows or trigger top-level navigations in
order to create a first-party context (as described in section 2.1), which is
only a speedbump along the road to exploitation.</t>
  <t>Features like <spanx style="verb">&lt;link rel='prerender'&gt;</spanx> <xref target="prerendering"/> can be exploited
to create first-party contexts without the risk of user detection. </t>
</list></t>

<t>In addition to the usual server-side defenses (CSRF tokens, etc), client-side
techniques such as those described in <xref target="app-isolation"/> may prove effective
against CSRF, and are certainly worth exploring in combination with
first-party-only cookies. First-party-only cookies on their own, however, are
not a substantial barrier to CSRF attacks.</t>

</section>
<section anchor="examples" title="Examples">

<t>First-party-only cookies are set via the <spanx style="verb">First-Party-Only</spanx> attribute in the
<spanx style="verb">Set-Cookie</spanx> header field. That is, given a server’s response to a user agent
which contains the following header field:</t>

<figure><artwork><![CDATA[
Set-Cookie: SID=31d4d96e407aad42; First-Party-Only
]]></artwork></figure>

<t>Subsequent requests from that user agent can be expected to contain the
following header field if and only if both the requested resource and the
resource in the top-level browsing context match the cookie.</t>

</section>
</section>
<section anchor="terminology-and-notation" title="Terminology and notation">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in <xref target="RFC2119"/>.</t>

<t>This specification uses the Augmented Backus-Naur Form (ABNF) notation of
<xref target="RFC5234"/>.</t>

<t>Two sequences of octets are said to case-insensitively match each other if and
only if they are equivalent under the <spanx style="verb">i;ascii-casemap</spanx> collation defined in
<xref target="RFC4790"/>.</t>

<t>The terms “active document”, “ancestor browsing context”, “browsing context”,
“document”, “iframe srcdoc document”, “parent browsing context”, and “top-level
browsing context” are defined in the HTML Living Standard <xref target="HTML"/>.</t>

<t>“Web Workers”, “dedicated workers”, “owner document”, “list of relevant
documents”, and “shared workers” are defined in the Web Workers specification
<xref target="WORKERS"/>.</t>

<t>“Service Workers” are defined in the Service Workers specification
<xref target="SERVICE-WORKERS"/>.</t>

<t>The term “origin”, the mechanism of deriving an origin from a URI, and the “the
same” matching algorithm for origins are defined in <xref target="RFC6454"/>.</t>

<section anchor="first-and-third-party" title="First-party and Third-party Requests">

<section anchor="document-based-requests" title="Document-based requests">

<t>When considering a request generated while parsing a document, or executing
script in its context, we need to consider the document’s origin as well as
the origin of each of it’s ancestors, in order to determine whether the
request should be considered “first-party”.</t>

<t>For this kind of request, the URI displayed in a user agent’s address bar is
the only security context directly exposed to users, and therefore the only
signal users can reasonably rely upon to determine whether or not they trust
a particular website. The origin of that URI is, therefore, the “first-party
origin”.</t>

<t>In order to prevent the kinds of “multiple-nested scenarios” described in
Section 4 of <xref target="RFC7034"/>, we must check the first-party origin against the
origins of each of a document’s ancestor browsing contexts’ active documents.
A document is considered a “first-party context” if and only if the origin
of its URI is the same as the first-party origin, <spanx style="strong">and</spanx> if each of the
active documents in its ancestors’ browsing contexts’ is a first-party context.</t>

<t>This definition has a few implications:</t>

<t><list style="symbols">
  <t>New windows create new first-party contexts (as the active document is
rendered into a top-level browsing context).</t>
  <t>Full-page navigations create new first-party contexts. Notably, this
includes both HTTP and <spanx style="verb">&lt;meta&gt;</spanx>-driven redirects.</t>
  <t><spanx style="verb">&lt;iframe&gt;</spanx>s do not create new first-party contexts; their requests MUST
be considered in the context of the origin of the URL the user actually
sees in the user agent’s address bar.</t>
</list></t>

<t>To be more precise, given an HTTP request <spanx style="verb">request</spanx>, the following algorithm
returns <spanx style="verb">First-Party</spanx> if <spanx style="verb">request</spanx> is a first-party request, and <spanx style="verb">Third-Party</spanx>
otherwise:</t>

<t><list style="numbers">
  <t>Let <spanx style="verb">document</spanx> be the document responsible for <spanx style="verb">request</spanx>.</t>
  <t>Return <spanx style="verb">First-Party</spanx> if <spanx style="verb">document</spanx> is a first-party context, and
<spanx style="verb">Third-Party</spanx> otherwise.</t>
</list></t>

<t>Given a Document <spanx style="verb">document</spanx>, the following algorithm returns <spanx style="verb">First-Party</spanx> if
<spanx style="verb">document</spanx> is a first-party context, and <spanx style="verb">Third-Party</spanx> otherwise:</t>

<t><list style="numbers">
  <t>Let <spanx style="verb">top-origin</spanx> be the origin of the URI of the active document in the
top-level browsing context of the document responsible for <spanx style="verb">request</spanx>.</t>
  <t>If <spanx style="verb">document</spanx>’s URI’s origin is not <spanx style="verb">top-origin</spanx>, return <spanx style="verb">Third-Party</spanx>.</t>
  <t>While <spanx style="verb">document</spanx> has a parent browsing context:  <list style="numbers">
      <t>Let <spanx style="verb">document</spanx> be <spanx style="verb">document</spanx>’s parent browsing context’s active
document.</t>
      <t>If <spanx style="verb">document</spanx>’s URI’s origin is not <spanx style="verb">top-origin</spanx> and <spanx style="verb">document</spanx> is not
an iframe srcdoc document, return <spanx style="verb">Third-Party</spanx>.</t>
    </list></t>
  <t>Return <spanx style="verb">First-Party</spanx>.</t>
</list></t>

<t>Note that we deal with the document’s location in steps 2, 3, and 4.2 above, not
with the document’s origin. For example, a top-level document from
<spanx style="verb">https://example.com</spanx> which has been sandboxed into a unique origin still
creates a non-unique first-party context for subsequent requests.</t>

</section>
<section anchor="worker-based-requests" title="Worker-based requests">

<t>Worker-driven requests aren’t as clear-cut as document-driven requests, as
there isn’t a clear link between a top-level browsing context and a worker.
This is especially true for Service Workers <xref target="SERVICE-WORKERS"/>, which may
execute code in the background, without any document visible at all.</t>

<t>Note: The descriptions below assume that workers must be same-origin with
the documents that instantiate them. If this invariant changes, we’ll need to
take the worker’s script’s URI into account when determining their status.</t>

<section anchor="dedicated-workers" title="Dedicated Workers">

<t>Dedicated workers are fairly straightforward to categorize, as each dedicated
worker is bound to one and only one Document. Requests generated from a
dedicated worker (via <spanx style="verb">importScripts</spanx>, <spanx style="verb">XMLHttpRequest</spanx>, <spanx style="verb">fetch()</spanx>, and so on)
are first-party requests if and only if the worker’s owner document is a
first-party context.</t>

<t>To be more precise, given an HTTP request <spanx style="verb">request</spanx>, the following algorithm
returns <spanx style="verb">First-Party</spanx> if <spanx style="verb">request</spanx> is a first-party request, and <spanx style="verb">Third-Party</spanx>
otherwise:</t>

<t><list style="numbers">
  <t>Let <spanx style="verb">worker</spanx> be the dedicated worker responsible for <spanx style="verb">request</spanx>.</t>
  <t>Let <spanx style="verb">document</spanx> be <spanx style="verb">worker</spanx>’s owner document.</t>
  <t>Return <spanx style="verb">First-Party</spanx> if <spanx style="verb">document</spanx> is a first-party context (as defined in
section 2.1.1), and <spanx style="verb">Third-Party</spanx> otherwise.</t>
</list></t>

</section>
<section anchor="shared-workers" title="Shared Workers">

<t>Shared Workers introduce the complexity of bindings to multiple Documents. As
it is quite possible for a shared worker to be bound at the same time to one
Document that is a first-party context, and another that isn’t, we’ll need to
walk through all the documents associated with the worker to determine its
status. If and only if all associated documents are first-party contexts, then
the worker is a first-party context.</t>

<t>To be more precise, given an HTTP request <spanx style="verb">request</spanx>, the following algorithm
returns <spanx style="verb">First-Party</spanx> if <spanx style="verb">request</spanx> is a first-party request, and <spanx style="verb">Third-Party</spanx>
otherwise:</t>

<t><list style="numbers">
  <t>Let <spanx style="verb">worker</spanx> be the dedicated worker responsible for <spanx style="verb">request</spanx>.</t>
  <t>For each <spanx style="verb">document</spanx> in <spanx style="verb">worker</spanx>’s list of relevant Documents:  <list style="numbers">
      <t>Return <spanx style="verb">Third-Party</spanx> if <spanx style="verb">document</spanx> is not a first-party context (as
defined in section 2.1.1).</t>
    </list></t>
  <t>Return <spanx style="verb">First-Party</spanx>.</t>
</list></t>

</section>
<section anchor="service-workers" title="Service Workers">

<t>Service Workers are more complex still, as they act as a completely separate
execution context, with very little relationship to the Document which
registered them.</t>

<t>Until we have more implementation experience, we will consider Service Workers
as third-party contexts in all cases.</t>

<t>Note: Requests which simply pass through a service worker will be handled as described
above; the only requests which will be effected by this categorization are those which
the service worker itself initiates (via <spanx style="verb">fetch()</spanx>, for instance).</t>

</section>
</section>
</section>
</section>
<section anchor="server-requirements" title="Server Requirements">

<t>This section describes extensions to <xref target="RFC6265"/> necessary to implement the
server-side requirements of the <spanx style="verb">First-Party-Only</spanx> attribute.</t>

<section anchor="grammar" title="Grammar">

<t>Add <spanx style="verb">First-Party-Only</spanx> to the list of accepted attributes in the <spanx style="verb">Set-Cookie</spanx>
header field’s value by replacing the <spanx style="verb">cookie-av</spanx> token definition in Section
4.1.1 of <xref target="RFC6265"/> with the following ABNF grammar:</t>

<figure><artwork><![CDATA[
cookie-av           = expires-av / max-age-av / domain-av /
                      path-av / secure-av / httponly-av /
                      first-party-only-av / extension-av
first-party-only-av = "First-Party-Only"
]]></artwork></figure>

</section>
<section anchor="semantics-of-the-first-party-only-attribute-non-normative" title="Semantics of the “First-Party-Only” Attribute (Non-Normative)">

<t>The “First-Party-Only” attribute limits the scope of the cookie such that it
will only be attached to requests if those requests are “first-party”, as
described in <xref target="first-and-third-party"/>. For example, requests for
<spanx style="verb">https://example.com/sekrit-image</spanx> will attach first-party-only cookies if and
only if the top-level browsing context is currently displaying a document from
<spanx style="verb">https://example.com</spanx>.</t>

<t>The changes to the <spanx style="verb">Cookie</spanx> header field suggested in <xref target="cookie-header"/> provide
additional detail.</t>

</section>
</section>
<section anchor="user-agent-requirements" title="User Agent Requirements">

<t>This section describes extensions to <xref target="RFC6265"/> necessary in order to implement
the client-side requirements of the <spanx style="verb">First-Party-Only</spanx> attribute.</t>

<section anchor="the-first-party-attribute" title="The “First-Party” attribute">

<t>The following attribute definition should be considered part of the the
<spanx style="verb">Set-Cookie</spanx> algorithm as described in Section 5.2 of <xref target="RFC6265"/>:</t>

<t>If the attribute-name case-insensitively matches the string “First-Party-Only”,
the user agent MUST append an attribute to the <spanx style="verb">cookie-attribute-list</spanx> with an
<spanx style="verb">attribute-name</spanx> of “First-Party-Only” and an empty <spanx style="verb">attribute-value</spanx>.</t>

</section>
<section anchor="monkey-patching-the-storage-model" title="Monkey-patching the Storage Model">

<t>Note: There’s got to be a better way to specify this. Until I figure out
what that is, monkey-patching!</t>

<t>Alter Section 5.3 of <xref target="RFC6265"/> as follows:</t>

<t><list style="numbers">
  <t>Add <spanx style="verb">first-party-only-flag</spanx> to the list of fields stored for each cookie.</t>
  <t>Before step 11 of the current algorithm, add the following:  <list style="numbers">
      <t>If the <spanx style="verb">cookie-attribute-list</spanx> contains an attribute with an
<spanx style="verb">attribute-name</spanx> of “First-Party-Only”, set the cookie’s
<spanx style="verb">first-party-only-flag</spanx> to true. Otherwise, set the cookie’s
<spanx style="verb">first-party-only-flag</spanx> to false.</t>
      <t>If the cookie’s <spanx style="verb">first-party-only-flag</spanx> is set to true, and the request
which generated the cookie is not a first-party request (as defined
in <xref target="first-and-third-party"/>), then abort these steps and ignore the
newly created cookie entirely.</t>
    </list></t>
</list></t>

</section>
<section anchor="cookie-header" title="Monkey-patching the “Cookie” header">

<t>Note: There’s got to be a better way to specify this. Until I figure out
what that is, monkey-patching!</t>

<t>Alter Section 5.4 of <xref target="RFC6265"/> as follows:</t>

<t><list style="numbers">
  <t>Add the following requirement to the list in step 1:  <list style="symbols">
      <t>If the cookie’s <spanx style="verb">first-party-only-flag</spanx> is true, then exclude the cookie
if the HTTP request is a third-party request (see
<xref target="first-and-third-party"/>).</t>
    </list></t>
</list></t>

<t>Note that the modifications suggested here concern themselves only with the
origin of the top-level browsing context and the origin of the resource being
requested. The cookie’s <spanx style="verb">domain</spanx>, <spanx style="verb">path</spanx>, and <spanx style="verb">secure</spanx> attributes do not come
into play for this comparison.</t>

</section>
</section>
<section anchor="authoring-considerations" title="Authoring Considerations">

<section anchor="mashups-and-widgets" title="Mashups and Widgets">

<t>The <spanx style="verb">First-Party-Only</spanx> attribute is inappropriate for some important use-cases.
In particular, note that content intended for embedding in a third-party context
(social networking widgets or commenting services, for instance) will not have
access to first-party-only cookies. Non-first-party cookies may be required in
order to provide seamless functionality that relies on a user’s state.</t>

<t>Likewise, some forms of Single-Sign On might require authentication in a
third-party context; these mechanisms will not function as intended with
first-party-only cookies.</t>

</section>
</section>
<section anchor="privacy-considerations" title="Privacy Considerations">

<t>First-party-only cookies in and of themselves don’t do anything to address the
general privacy concerns outlined in Section 7.1 of <xref target="RFC6265"/>. The attribute
is set by the server, and serves to mitigate the risk of certain kinds of
attacks that the server is worried about. The user is not involved in this
decision. Moreover, a number of side-channels exist which could allow a server
to link distinct requests even in the absence of cookies. Connection and/or
socket pooling, Token Binding, and Channel ID all offer explicit methods of
identification that servers could take advantage of.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

<reference anchor="HTML" target="https://html.spec.whatwg.org/">
  <front>
    <title>HTML Living Standard</title>
    <author initials="I." surname="Hickson" fullname="Ian Hickson">
      <organization>Google, Inc.</organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="SERVICE-WORKERS" target="http://www.w3.org/TR/service-workers/">
  <front>
    <title>Service Workers</title>
    <author initials="A." surname="Russell" fullname="Alex Russell">
      <organization></organization>
    </author>
    <author initials="J." surname="Song" fullname="Jungkee Song">
      <organization></organization>
    </author>
    <author initials="J." surname="Archibald" fullname="Jake Archibald">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="WORKERS" target="http://www.w3.org/TR/workers/">
  <front>
    <title>Web Workers</title>
    <author initials="I." surname="Hickson" fullname="Ian Hickson">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
&RFC2119;
&RFC4790;
&RFC5234;
&RFC6265;
&RFC6454;
&RFC7034;


    </references>

    <references title='Informative References'>

<reference anchor="samedomain-cookies" target="http://people.mozilla.org/~mgoodwin/SameDomain/samedomain-latest.txt">
  <front>
    <title>SameDomain Cookie Flag</title>
    <author initials="M." surname="Goodwin" fullname="Mark Goodwin">
      <organization></organization>
    </author>
    <author initials="J." surname="Walker" fullname="Joe Walker">
      <organization></organization>
    </author>
    <date year="2011"/>
  </front>
</reference>
<reference anchor="pixel-perfect" target="http://www.contextis.com/documents/2/Browser_Timing_Attacks.pdf">
  <front>
    <title>Pixel Perfect Timing Attacks with HTML5</title>
    <author initials="P." surname="Stone" fullname="Paul Stone">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="app-isolation" target="http://www.collinjackson.com/research/papers/appisolation.pdf">
  <front>
    <title>App Isolation - Get the Security of Multiple Browsers with Just One</title>
    <author initials="E." surname="Chen" fullname="Eric Y. Chen">
      <organization></organization>
    </author>
    <author initials="J." surname="Bau" fullname="Jason Bau">
      <organization></organization>
    </author>
    <author initials="C." surname="Reis" fullname="Charles Reis">
      <organization></organization>
    </author>
    <author initials="A." surname="Barth" fullname="Adam Barth">
      <organization></organization>
    </author>
    <author initials="C." surname="Jackson" fullname="Collin Jackson">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="prerendering" target="https://www.chromium.org/developers/design-documents/prerender">
  <front>
    <title>Chrome Prerendering</title>
    <author initials="C." surname="Bentzel" fullname="Chris Bentzel">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>


    </references>


<section anchor="acknowledgements" title="Acknowledgements">

<t>The first-party cookie concept documented here is indebited to Mark Goodwin’s
and Joe Walker’s <xref target="samedomain-cookies"/>. Michal Zalewski, Artur Janc, and Ryan
Sleevi provided particularly valuable feedback on this document.</t>

</section>


  </back>
</rfc>

