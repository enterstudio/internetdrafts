<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.28 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4790 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4790.xml">
<!ENTITY RFC5234 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml">
<!ENTITY RFC6265 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6265.xml">
<!ENTITY RFC6454 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6454.xml">
<!ENTITY RFC7231 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!ENTITY RFC7258 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7258.xml">
<!ENTITY RFC7034 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7034.xml">
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-west-first-party-cookies-07" category="std" updates="6265">

  <front>
    <title abbrev="first-party-cookies">Same-site Cookies</title>

    <author initials="M." surname="West" fullname="Mike West">
      <organization>Google, Inc</organization>
      <address>
        <email>mkwst@google.com</email>
        <uri>https://mikewest.org/</uri>
      </address>
    </author>
    <author initials="M." surname="Goodwin" fullname="Mark Goodwin">
      <organization>Mozilla</organization>
      <address>
        <email>mgoodwin@mozilla.com</email>
        <uri>https://www.computerist.org/</uri>
      </address>
    </author>

    <date year="2016"/>

    <area>General</area>
    <workgroup>HTTPbis</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document updates RFC6265 by defining a <spanx style="verb">SameSite</spanx> attribute which allows
servers to assert that a cookie ought not to be sent along with cross-site
requests. This assertion allows user agents to mitigate the risk of cross-origin
information leakage, and provides some protection against cross-site request
forgery attacks.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Section 8.2 of <xref target="RFC6265"/> eloquently notes that cookies are a form of ambient
authority, attached by default to requests the user agent sends on a user’s
behalf. Even when an attacker doesn’t know the contents of a user’s cookies,
she can still execute commands on the user’s behalf (and with the user’s
authority) by asking the user agent to send HTTP requests to unwary servers.</t>

<t>Here, we update <xref target="RFC6265"/> with a simple mitigation strategy that allows
servers to declare certain cookies as “same-site”, meaning they should not be
attached to “cross-site” requests (as defined in section 2.1).</t>

<t>Note that the mechanism outlined here is backwards compatible with the existing
cookie syntax. Servers may serve these cookies to all user agents; those that do
not support the <spanx style="verb">SameSite</spanx> attribute will simply store a cookie which is
attached to all relevant requests, just as they do today.</t>

<section anchor="goals" title="Goals">

<t>These cookies are intended to provide a solid layer of defense-in-depth against
attacks which require embedding an authenticated request into an
attacker-controlled context:</t>

<t><list style="numbers">
  <t>Timing attacks which yield cross-origin information leakage (such as those
detailed in <xref target="pixel-perfect"/>) can be substantially mitigated by setting
the <spanx style="verb">SameSite</spanx> attribute on authentication cookies. The attacker will
only be able to embed unauthenticated resources, as embedding mechanisms such
as <spanx style="verb">&lt;iframe&gt;</spanx> will yield cross-site requests.</t>
  <t>Cross-site script inclusion (XSSI) attacks are likewise mitigated by setting
the <spanx style="verb">SameSite</spanx> attribute on authentication cookies. The attacker will not be
able to include authenticated resources via <spanx style="verb">&lt;script&gt;</spanx> or <spanx style="verb">&lt;link&gt;</spanx>, as these
embedding mechanisms will likewise yield cross-site requests.</t>
  <t>Cross-site request forgery (CSRF) attacks which rely on top-level navigation
(HTML <spanx style="verb">&lt;form&gt;</spanx> POSTs, for instance) can also be mitigated by treating these
navigational requests as “cross-site”.</t>
  <t>Same-site cookies have some marginal value for policy or regulatory
purposes, as cookies which are not delivered with cross-site requests cannot
be directly used for tracking purposes. It may be valuable for an origin to
assert that its cookies should not be sent along with cross-site requests in
order to limit its exposure to non-technical risk.</t>
</list></t>

</section>
<section anchor="examples" title="Examples">

<t>Same-site cookies are set via the <spanx style="verb">SameSite</spanx> attribute in the <spanx style="verb">Set-Cookie</spanx>
header field. That is, given a server’s response to a user agent which contains
the following header field:</t>

<figure><artwork><![CDATA[
Set-Cookie: SID=31d4d96e407aad42; SameSite=Strict
]]></artwork></figure>

<t>Subsequent requests from that user agent can be expected to contain the
following header field if and only if both the requested resource and the
resource in the top-level browsing context match the cookie.</t>

</section>
</section>
<section anchor="terminology-and-notation" title="Terminology and notation">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in <xref target="RFC2119"/>.</t>

<t>This specification uses the Augmented Backus-Naur Form (ABNF) notation of
<xref target="RFC5234"/>.</t>

<t>Two sequences of octets are said to case-insensitively match each other if and
only if they are equivalent under the <spanx style="verb">i;ascii-casemap</spanx> collation defined in
<xref target="RFC4790"/>.</t>

<t>The terms “active document”, “ancestor browsing context”, “browsing context”,
“document”, “WorkerGlobalScope”, “sandboxed origin browsing context flag”,
“parent browsing context”, “the worker’s Documents”, “nested browsing context”,
and “top-level browsing context” are defined in <xref target="HTML"/>.</t>

<t>“Service Workers” are defined in the Service Workers specification
<xref target="SERVICE-WORKERS"/>.</t>

<t>The term “origin”, the mechanism of deriving an origin from a URI, and the “the
same” matching algorithm for origins are defined in <xref target="RFC6454"/>.</t>

<t>“Safe” HTTP methods include <spanx style="verb">GET</spanx>, <spanx style="verb">HEAD</spanx>, <spanx style="verb">OPTIONS</spanx>, and <spanx style="verb">TRACE</spanx>, as defined
in Section 4.2.1 of <xref target="RFC7231"/>.</t>

<t>The term “public suffix” is defined in a note in Section 5.3 of <xref target="RFC6265"/> as
“a domain that is controlled by a public registry”. For example, <spanx style="verb">example.com</spanx>’s
public suffix is <spanx style="verb">com</spanx>. User agents SHOULD use an up-to-date public suffix list,
such as the one maintained by Mozilla at <xref target="PSL"/>.</t>

<t>An origin’s “registrable domain” is the origin’s host’s public suffix plus the
label to its left. That is, <spanx style="verb">https://www.example.com</spanx>’s registrable domain is
<spanx style="verb">example.com</spanx>. This concept is defined more rigorously in <xref target="PSL"/>.</t>

<t>The term “request”, as well as a request’s “client”, “current url”, “method”,
and “target browsing context”, are defined in <xref target="FETCH"/>.</t>

<section anchor="same-site-requests" title="“Same-site” and “cross-site” Requests">

<t>A request is “same-site” if its target’s URI’s origin’s registrable domain
is an exact match for the request’s initiator’s “site for cookies”, and
“cross-site” otherwise. To be more precise, for a given request (“request”), the
following algorithm returns <spanx style="verb">same-site</spanx> or <spanx style="verb">cross-site</spanx>:</t>

<t><list style="numbers">
  <t>If <spanx style="verb">request</spanx>’s client is <spanx style="verb">null</spanx>, return <spanx style="verb">same-site</spanx>.</t>
  <t>Let <spanx style="verb">site</spanx> be <spanx style="verb">request</spanx>’s client’s “site for cookies” (as defined in the
following sections).</t>
  <t>Let <spanx style="verb">target</spanx> be the registrable domain of <spanx style="verb">request</spanx>’s current url.</t>
  <t>If <spanx style="verb">site</spanx> is an exact match for <spanx style="verb">target</spanx>, return <spanx style="verb">same-site</spanx>.</t>
  <t>Return <spanx style="verb">cross-site</spanx>.</t>
</list></t>

<section anchor="document-requests" title="Document-based requests">

<t>The URI displayed in a user agent’s address bar is the only security context
directly exposed to users, and therefore the only signal users can reasonably
rely upon to determine whether or not they trust a particular website. The
registrable domain of that URI’s origin represents the context in which a user
most likely believes themselves to be interacting. We’ll label this domain the
“top-level site”.</t>

<t>For a document displayed in a top-level browsing context, we can stop here: the
document’s “site for cookies” is the top-level site.</t>

<t>For documents which are displayed in nested browsing contexts, we need to audit
the origins of each of a document’s ancestor browsing contexts’ active documents
in order to account for the “multiple-nested scenarios” described in Section 4
of <xref target="RFC7034"/>. These document’s “site for cookies” is the top-level site if and
only if the document and each of its ancestor documents’ origins have the same
registrable domain as the top-level site. Otherwise its “site for cookies” is
the empty string.</t>

<t>Given a Document (<spanx style="verb">document</spanx>), the following algorithm returns its “site for
cookies” (either a registrable domain, or the empty string):</t>

<t><list style="numbers">
  <t>Let <spanx style="verb">top-document</spanx> be the active document in <spanx style="verb">document</spanx>’s browsing context’s
top-level browsing context.</t>
  <t>Let <spanx style="verb">top-origin</spanx> be the origin of <spanx style="verb">top-document</spanx>’s URI if <spanx style="verb">top-document</spanx>’s
sandboxed origin browsing context flag is set, and <spanx style="verb">top-document</spanx>’s origin
otherwise.</t>
  <t>Let <spanx style="verb">documents</spanx> be an empty list be a list containing <spanx style="verb">document</spanx> and each of
<spanx style="verb">document</spanx>’s ancestor browsing contexts’ active documents.</t>
  <t>For each <spanx style="verb">item</spanx> in <spanx style="verb">documents</spanx>:  <list style="numbers">
      <t>Let <spanx style="verb">origin</spanx> be the origin of <spanx style="verb">item</spanx>’s URI if <spanx style="verb">item</spanx>’s sandboxed origin
browsing context flag is set, and <spanx style="verb">item</spanx>’s origin otherwise.</t>
      <t>If <spanx style="verb">origin</spanx>’s host’s registrable domain is not an exact match for
<spanx style="verb">top-origin</spanx>’s host’s registrable domain, return the empty string.</t>
    </list></t>
  <t>Return <spanx style="verb">top-site</spanx>.</t>
</list></t>

</section>
<section anchor="worker-requests" title="Worker-based requests">

<t>Worker-driven requests aren’t as clear-cut as document-driven requests, as
there isn’t a clear link between a top-level browsing context and a worker.
This is especially true for Service Workers <xref target="SERVICE-WORKERS"/>, which may
execute code in the background, without any document visible at all.</t>

<t>Note: The descriptions below assume that workers must be same-origin with
the documents that instantiate them. If this invariant changes, we’ll need to
take the worker’s script’s URI into account when determining their status.</t>

<section anchor="dedicated-and-shared-requests" title="Dedicated and Shared Workers">

<t>Dedicated workers are simple, as each dedicated worker is bound to one and only
one document. Requests generated from a dedicated worker (via <spanx style="verb">importScripts</spanx>,
<spanx style="verb">XMLHttpRequest</spanx>, <spanx style="verb">fetch()</spanx>, etc) define their “site for cookies” as that
document’s “site for cookies”.</t>

<t>Shared workers may be bound to multiple documents at once. As it is quite
possible for those documents to have distinct “site for cookie” values, the
worker’s “site for cookies” will be the empty string in cases where the values
diverge, and the shared value in cases where the values agree.</t>

<t>Given a WorkerGlobalScope (<spanx style="verb">worker</spanx>), the following algorithm returns its “site
for cookies” (either a registrable domain, or the empty string):</t>

<t><list style="numbers">
  <t>Let <spanx style="verb">site</spanx> be <spanx style="verb">worker</spanx>’s origin’s host’s registrable domain.</t>
  <t>For each <spanx style="verb">document</spanx> in <spanx style="verb">worker</spanx>’s Documents:  <list style="numbers">
      <t>Let <spanx style="verb">document-site</spanx> be <spanx style="verb">document</spanx>’s “site for cookies” (as defined
in <xref target="document-requests"/>).</t>
      <t>If <spanx style="verb">document-site</spanx> is not an exact match for <spanx style="verb">site</spanx>, return the empty
string.</t>
    </list></t>
  <t>Return <spanx style="verb">site</spanx>.</t>
</list></t>

</section>
<section anchor="service-workers" title="Service Workers">

<t>Service Workers are more complicated, as they act as a completely separate
execution context with only tangential relationship to the Document which
registered them.</t>

<t>Requests which simply pass through a service worker will be handled as described
above: the request’s client will be the Document or Worker which initiated the
request, and its “site for cookies” will be those defined in
<xref target="document-requests"/> and <xref target="dedicated-and-shared-requests"/></t>

<t>Requests which are initiated by the Service Worker itself (via a direct call to
<spanx style="verb">fetch()</spanx>, for instance), on the other hand, will have a client which is a
ServiceWorkerGlobalScope. Its “site for cookies” will be the registrable domain
of the Service Worker’s URI.</t>

<t>Given a ServiceWorkerGlobalScope (<spanx style="verb">worker</spanx>), the following algorithm returns its
“site for cookies” (either a registrable domain, or the empty string):</t>

<t><list style="numbers">
  <t>Return <spanx style="verb">worker</spanx>’s origin’s host’s registrable domain.</t>
</list></t>

</section>
</section>
</section>
</section>
<section anchor="server-requirements" title="Server Requirements">

<t>This section describes extensions to <xref target="RFC6265"/> necessary to implement the
server-side requirements of the <spanx style="verb">SameSite</spanx> attribute.</t>

<section anchor="grammar" title="Grammar">

<t>Add <spanx style="verb">SameSite</spanx> to the list of accepted attributes in the <spanx style="verb">Set-Cookie</spanx> header
field’s value by replacing the <spanx style="verb">cookie-av</spanx> token definition in Section 4.1.1
of <xref target="RFC6265"/> with the following ABNF grammar:</t>

<figure><artwork><![CDATA[
cookie-av      = expires-av / max-age-av / domain-av /
                 path-av / secure-av / httponly-av /
                 samesite-av / extension-av
samesite-av    = "SameSite" / "SameSite=" samesite-value
samesite-value = "Strict" / "Lax"
]]></artwork></figure>

</section>
<section anchor="semantics-of-the-samesite-attribute-non-normative" title="Semantics of the “SameSite” Attribute (Non-Normative)">

<t>The “SameSite” attribute limits the scope of the cookie such that it will only
be attached to requests if those requests are “same-site”, as defined by the
algorithm in <xref target="same-site-requests"/>. For example, requests for
<spanx style="verb">https://example.com/sekrit-image</spanx> will attach same-site cookies if and only if
initiated from a context whose “site for cookies” is “example.com”.</t>

<t>If the “SameSite” attribute has no value, if the value is “Strict”, or if the
value is invalid, the cookie will only be sent along with “same-site” requests.
If the value is “Lax”, the cookie will be sent with “same-site” requests, and
with “cross-site” top-level navigations, as described in <xref target="strict-lax"/>.</t>

<t>The changes to the <spanx style="verb">Cookie</spanx> header field suggested in <xref target="cookie-header"/> provide
additional detail.</t>

</section>
</section>
<section anchor="user-agent-requirements" title="User Agent Requirements">

<t>This section describes extensions to <xref target="RFC6265"/> necessary in order to implement
the client-side requirements of the <spanx style="verb">SameSite</spanx> attribute.</t>

<section anchor="the-samesite-attribute" title="The “SameSite” attribute">

<t>The following attribute definition should be considered part of the the
<spanx style="verb">Set-Cookie</spanx> algorithm as described in Section 5.2 of <xref target="RFC6265"/>:</t>

<t>If the <spanx style="verb">attribute-name</spanx> case-insensitively matches the string “SameSite”, the
user agent MUST process the <spanx style="verb">cookie-av</spanx> as follows:</t>

<t><list style="numbers">
  <t>Let <spanx style="verb">enforcement</spanx> be “Strict”.</t>
  <t>If <spanx style="verb">cookie-av</spanx>’s <spanx style="verb">attribute-value</spanx> is a case-insensitive match for either
“Strict” or “Lax”, set <spanx style="verb">enforcement</spanx> to <spanx style="verb">cookie-av</spanx>’s <spanx style="verb">attribute-value</spanx>.</t>
  <t>Append an attribute to the <spanx style="verb">cookie-attribute-list</spanx> with an <spanx style="verb">attribute-name</spanx>
of “SameSite” and an <spanx style="verb">attribute-value</spanx> of <spanx style="verb">enforcement</spanx>.</t>
</list></t>

<section anchor="strict-lax" title="“Strict” and “Lax” enforcement">

<t>By default, same-site cookies will not be sent along with top-level navigations.
As discussed in <xref target="top-level-navigations"/>, this might or might not be compatible
with existing session management systems. In the interests of providing a
drop-in mechanism that mitigates the risk of CSRF attacks, developers may set
the <spanx style="verb">SameSite</spanx> attribute in a “Lax” enforcement mode that carves out an
exception which sends same-site cookies along with cross-site requests if and
only if they are top-level navigations which use a “safe” (in the <xref target="RFC7231"/>
sense) HTTP method.</t>

<t>Lax enforcement provides reasonable defense in depth against CSRF attacks that
rely on unsafe HTTP methods (like <spanx style="verb">POST</spanx>), but do not offer a robust defense
against CSRF as a general category of attack:</t>

<t><list style="numbers">
  <t>Attackers can still pop up new windows or trigger top-level navigations in
order to create a “same-site” request (as described in section 2.1), which is
only a speedbump along the road to exploitation.</t>
  <t>Features like <spanx style="verb">&lt;link rel='prerender'&gt;</spanx> <xref target="prerendering"/> can be exploited
to create “same-site” requests without the risk of user detection.</t>
</list></t>

<t>When possible, developers should use a session management mechanism such as
that described in <xref target="top-level-navigations"/> to mitigate the risk of CSRF more
completely.</t>

</section>
</section>
<section anchor="monkey-patching-the-storage-model" title="Monkey-patching the Storage Model">

<t>Note: There’s got to be a better way to specify this. Until I figure out
what that is, monkey-patching!</t>

<t>Alter Section 5.3 of <xref target="RFC6265"/> as follows:</t>

<t><list style="numbers">
  <t>Add <spanx style="verb">samesite-flag</spanx> to the list of fields stored for each cookie. This
field’s value is one of “None”, “Strict”, or “Lax”.</t>
  <t>Before step 11 of the current algorithm, add the following:  <list style="numbers">
      <t>If the <spanx style="verb">cookie-attribute-list</spanx> contains an attribute with an
<spanx style="verb">attribute-name</spanx> of “SameSite”, set the cookie’s <spanx style="verb">samesite-flag</spanx> to
<spanx style="verb">attribute-value</spanx> (“Strict” or “Lax”). Otherwise, set the cookie’s
<spanx style="verb">samesite-flag</spanx> to “None”.</t>
      <t>If the cookie’s <spanx style="verb">samesite-flag</spanx> is not “None”, and the request
which generated the cookie’s client’s “site for cookies” is not an
exact match for <spanx style="verb">request-uri</spanx>’s host’s registrable domain, then
abort these steps and ignore the newly created cookie entirely.</t>
    </list></t>
</list></t>

</section>
<section anchor="cookie-header" title="Monkey-patching the “Cookie” header">

<t>Note: There’s got to be a better way to specify this. Until I figure out
what that is, monkey-patching!</t>

<t>Alter Section 5.4 of <xref target="RFC6265"/> as follows:</t>

<t><list style="numbers">
  <t>Add the following requirement to the list in step 1:  <list style="symbols">
      <t>If the cookie’s <spanx style="verb">samesite-flag</spanx> is not “None”, and the HTTP request is
cross-site (as defined in <xref target="same-site-requests"/> then exclude the cookie
unless all of the following statements hold:      <list style="numbers">
          <t><spanx style="verb">samesite-flag</spanx> is “Lax”</t>
          <t>The HTTP request’s method is “safe”.</t>
          <t>The HTTP request’s target browsing context is a top-level browsing
context.</t>
        </list></t>
    </list></t>
</list></t>

<t>Note that the modifications suggested here concern themselves only with the
“site for cookies” of the request’s client, and the registrable domain of the
resource being requested. The cookie’s <spanx style="verb">domain</spanx>, <spanx style="verb">path</spanx>, and <spanx style="verb">secure</spanx> attributes
do not come into play for these comparisons.</t>

</section>
</section>
<section anchor="authoring-considerations" title="Authoring Considerations">

<section anchor="defense-in-depth" title="Defense in depth">

<t>“SameSite” cookies offer a robust defense against CSRF attack when deployed in
strict mode, and when supported by the client. It is, however, prudent to ensure
that this designation is not the extent of a site’s defense against CSRF, as
same-site navigations and submissions can certainly be executed in conjunction
with other attack vectors such as cross-site scripting.</t>

<t>Developers are strongly encouraged to deploy the usual server-side defenses
(CSRF tokens, ensuring that “safe” HTTP methods are idempotent, etc) to mitigate
the risk more fully.</t>

<t>Additionally, client-side techniques such as those described in
<xref target="app-isolation"/> may also prove effective against CSRF, and are certainly worth
exploring in combination with “SameSite” cookies.</t>

</section>
<section anchor="top-level-navigations" title="Top-level Navigations">

<t>Setting the <spanx style="verb">SameSite</spanx> attribute in “strict” mode provides robust defense in
depth against CSRF attacks, but has the potential to confuse users unless sites’
developers carefully ensure that their session management systems deal
reasonably well with top-level navigations.</t>

<t>Consider the scenario in which a user reads their email at MegaCorp Inc’s
webmail provider <spanx style="verb">https://example.com/</spanx>. They might expect that clicking on an
emailed link to <spanx style="verb">https://projects.com/secret/project</spanx> would show them the secret
project that they’re authorized to see, but if <spanx style="verb">projects.com</spanx> has marked their
session cookies as <spanx style="verb">SameSite</spanx>, then this cross-site navigation won’t send them
along with the request. <spanx style="verb">projects.com</spanx> will render a 404 error to avoid leaking
secret information, and the user will be quite confused.</t>

<t>Developers can avoid this confusion by adopting a session management system that
relies on not one, but two cookies: one conceptualy granting “read” access,
another granting “write” access. The latter could be marked as <spanx style="verb">SameSite</spanx>, and
its absence would provide a reauthentication step before executing any
non-idempotent action. The former could drop the <spanx style="verb">SameSite</spanx> attribute entirely,
or choose the “Lax” version of enforcement, in order to allow users access to
data via top-level navigation.</t>

</section>
<section anchor="mashups-and-widgets" title="Mashups and Widgets">

<t>The <spanx style="verb">SameSite</spanx> attribute is inappropriate for some important use-cases. In
particular, note that content intended for embedding in a cross-site contexts
(social networking widgets or commenting services, for instance) will not have
access to such cookies. Cross-site cookies may be required in order to provide
seamless functionality that relies on a user’s state.</t>

<t>Likewise, some forms of Single-Sign-On might require authentication in a
cross-site context; these mechanisms will not function as intended with
same-site cookies.</t>

</section>
</section>
<section anchor="privacy-considerations" title="Privacy Considerations">

<section anchor="server-controlled" title="Server-controlled">

<t>Same-site cookies in and of themselves don’t do anything to address the
general privacy concerns outlined in Section 7.1 of <xref target="RFC6265"/>. The attribute
is set by the server, and serves to mitigate the risk of certain kinds of
attacks that the server is worried about. The user is not involved in this
decision. Moreover, a number of side-channels exist which could allow a server
to link distinct requests even in the absence of cookies. Connection and/or
socket pooling, Token Binding, and Channel ID all offer explicit methods of
identification that servers could take advantage of.</t>

</section>
<section anchor="pervasive-monitoring" title="Pervasive Monitoring">

<t>As outlined in <xref target="RFC7258"/>, pervasive monitoring is an attack. Cookies play a
large part in enabling such monitoring, as they are responsible for maintaining
state in HTTP connections. We considered restricting same-site cookies to
secure contexts <xref target="secure-contexts"/> as a mitigation but decided against doing
so, as this feature should result in a strict reduction in the number of cookies
floating around in cross-site contexts. That is, even if
<spanx style="verb">http://not-example.com</spanx> embeds a resource from <spanx style="verb">http://example.com/</spanx>, that
resource will not be “same-site”, and <spanx style="verb">http://example.com</spanx>’s cookies simply
cannot be used to correlate user behavior across distinct origins.</t>

</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>

<reference anchor="FETCH" target="https://fetch.spec.whatwg.org/">
  <front>
    <title>Fetch</title>
    <author initials="A." surname="van Kesteren" fullname="Anne van Kesteren">
      <organization>Mozilla</organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="HTML" target="https://html.spec.whatwg.org/">
  <front>
    <title>HTML</title>
    <author initials="I." surname="Hickson" fullname="Ian Hickson">
      <organization>Google, Inc.</organization>
    </author>
    <author initials="S." surname="Pieters" fullname="Simon Pieters">
      <organization>Opera</organization>
    </author>
    <author initials="A." surname="van Kesteren" fullname="Anne van Kesteren">
      <organization>Mozilla</organization>
    </author>
    <author initials="P." surname="Jägenstedt" fullname="Philip Jägenstedt">
      <organization>Opera</organization>
    </author>
    <author initials="D." surname="Denicola" fullname="Domenic Denicola">
      <organization>Google, Inc.</organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="SERVICE-WORKERS" target="http://www.w3.org/TR/service-workers/">
  <front>
    <title>Service Workers</title>
    <author initials="A." surname="Russell" fullname="Alex Russell">
      <organization></organization>
    </author>
    <author initials="J." surname="Song" fullname="Jungkee Song">
      <organization></organization>
    </author>
    <author initials="J." surname="Archibald" fullname="Jake Archibald">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="PSL" target="https://publicsuffix.org/list/">
  <front>
    <title>Public Suffix List</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
&RFC2119;
&RFC4790;
&RFC5234;
&RFC6265;
&RFC6454;
&RFC7231;
&RFC7258;


    </references>

    <references title='Informative References'>

&RFC7034;
<reference anchor="samedomain-cookies" target="http://people.mozilla.org/~mgoodwin/SameDomain/samedomain-latest.txt">
  <front>
    <title>SameDomain Cookie Flag</title>
    <author initials="M." surname="Goodwin" fullname="Mark Goodwin">
      <organization></organization>
    </author>
    <author initials="J." surname="Walker" fullname="Joe Walker">
      <organization></organization>
    </author>
    <date year="2011"/>
  </front>
</reference>
<reference anchor="pixel-perfect" target="http://www.contextis.com/documents/2/Browser_Timing_Attacks.pdf">
  <front>
    <title>Pixel Perfect Timing Attacks with HTML5</title>
    <author initials="P." surname="Stone" fullname="Paul Stone">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="app-isolation" target="http://www.collinjackson.com/research/papers/appisolation.pdf">
  <front>
    <title>App Isolation - Get the Security of Multiple Browsers with Just One</title>
    <author initials="E." surname="Chen" fullname="Eric Y. Chen">
      <organization></organization>
    </author>
    <author initials="J." surname="Bau" fullname="Jason Bau">
      <organization></organization>
    </author>
    <author initials="C." surname="Reis" fullname="Charles Reis">
      <organization></organization>
    </author>
    <author initials="A." surname="Barth" fullname="Adam Barth">
      <organization></organization>
    </author>
    <author initials="C." surname="Jackson" fullname="Collin Jackson">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="prerendering" target="https://www.chromium.org/developers/design-documents/prerender">
  <front>
    <title>Chrome Prerendering</title>
    <author initials="C." surname="Bentzel" fullname="Chris Bentzel">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="secure-contexts" target="https://w3c.github.io/webappsec-secure-contexts/">
  <front>
    <title>Secure Contexts</title>
    <author initials="M." surname="West" fullname="Mike West">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>


    </references>


<section anchor="acknowledgements" title="Acknowledgements">

<t>The same-site cookie concept documented here is indebited to Mark Goodwin’s
and Joe Walker’s <xref target="samedomain-cookies"/>. Michal Zalewski, Artur Janc, and Ryan
Sleevi provided particularly valuable feedback on this document.</t>

</section>


  </back>
</rfc>

